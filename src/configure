#!/usr/bin/env gsi-script

(define features
  '((libxml  . #f)
    (libyaml . #f)
    (zlib    . #t)
    (sqlite  . #t)
    (mysql   . #f)
    (lmdb    . #f)
    (leveldb . #f)))

(define files-to-patch
  '("gerbil/gxc"
    "std/build-features.ss"))

(define-record-type :patch
  (make-patch replacement prefix substrings)
  patch?
  (replacement patch-replacement)
  (prefix      patch-prefix)
  (substrings  patch-substrings))

(define (patch-prefix-matches-line? patch line)
  (let* ((prefix     (patch-prefix patch))
         (prefix-len (string-length prefix)))
    (and (<= prefix-len (string-length line))
         (string=? prefix (substring line 0 prefix-len)))))

(define (patch-matches-line? patch line)
  (and (patch-prefix-matches-line? patch line)
       (fold (lambda (substring answer)
               (and answer (string-contains? line substring)))
             #t
             (patch-substrings patch))))

(define (patch-apply patch line)
  (if (patch-matches-line? patch line)
    (patch-replacement patch)
    line))

(define (die . message-bits)
  (parameterize ((current-output-port (current-error-port)))
    (display "*** ERROR; ")
    (for-each display message-bits)
    (newline))
  (exit 1))

(define (enable-feature! feature value)
  (let ((cell (assq (string->symbol feature) features)))
    (if (not cell)
      (die "Unknown feature: " feature))
    (set-cdr! cell value)))

(define (feature-patches)
  (map (lambda (feature)
         (define prefix
           (string-append "(enable " (symbol->string (car feature)) " "))
         (define replacement
           (string-append prefix (object->string (cdr feature)) ")\n"))
         (make-patch replacement prefix '()))
       features))

(define (prefix s prefix)
  (let ((prefix-length (string-length prefix))
        (s-length      (string-length s)))
    (if (and (<= prefix-length (string-length s))
             (string=? prefix (substring s 0 prefix-length)))
      (substring s prefix-length s-length)
      #f)))

(define (parse-args args)
  (let loop ((args args))
    (cond
     ((null? args)
      #f)
     ((prefix (car args) "--enable-") =>
      (lambda (feature)
        (enable-feature! feature #t)
        (loop (cdr args))))
     ((prefix (car args) "--disable-") =>
      (lambda (feature)
        (enable-feature! feature #f)
        (loop (cdr args))))
     (else
      (die "Unknown option: " (car args))))))

(define (for-each-line proc)
  (let loop ()
    (let ((line (read-line (current-input-port) #\newline #t)))
      (if (not (eof-object? line))
        (begin
         (proc line)
         (loop))))))

(define (string-contains? s find)
  (let ((find-len (string-length find)))
    (let loop ((i 0))
      (cond
       ((< (string-length s) (+ i find-len))
        #f)
       ((string=? find (substring s i (+ i find-len))))
       (else
        (loop (+ 1 i)))))))

(define (patch-file filename patches)
  (define (apply-patches line)
    (fold patch-apply line patches))
  (let ((new-content (with-input-from-file filename
                       (lambda ()
                         (with-output-to-string
                           (lambda ()
                             (for-each-line
                               (lambda (line)
                                 (display (apply-patches line))))))))))
    (with-output-to-file filename
      (lambda ()
        (display new-content)))))

(define (main . args)
  (parse-args args)
  (let ((patches (append (list (make-patch "#!/tmp/bin/gxi\n" "#!" '("gxi")))
                         (feature-patches))))
    (for-each (lambda (filename)
                (patch-file filename patches))
              files-to-patch)))
